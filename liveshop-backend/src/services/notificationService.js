const { Notification } = require('../models');
const { sequelize } = require('../config/database');
const notificationQueue = require('./notificationQueue');
const webPushService = require('./webPushService');

class NotificationService {
  constructor() {
    this.retryQueue = new Map(); // Fallback si BullMQ indisponible
    this.maxRetries = 3;
    this.retryDelay = 5000; // 5 secondes
    this.isProcessing = false;
    this.useBullMQ = false; // Flag pour savoir si BullMQ est actif
  }

  // Initialiser avec BullMQ
  async initializeQueue() {
    try {
      await notificationQueue.initialize(this);
      this.useBullMQ = notificationQueue.isInitialized;
      if (this.useBullMQ) {
        console.log('‚úÖ NotificationService utilise BullMQ pour les retries');
      } else {
        console.log('‚ö†Ô∏è  NotificationService utilise la queue en m√©moire (fallback)');
      }
    } catch (error) {
      console.error('‚ùå Erreur initialisation queue:', error);
      this.useBullMQ = false;
    }
  }

  // Cr√©er une notification persistante
  async createNotification(sellerId, type, title, message, data = null) {
    try {
      const notification = await Notification.create({
        seller_id: sellerId,
        type,
        title,
        message,
        data,
        read: false,
        sent: false,
        retry_count: 0,
        max_retries: 3
      });

      console.log(`üìù Notification cr√©√©e: ${type} pour vendeur ${sellerId} (ID: ${notification.id})`);
      return notification;
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation notification:', error);
      throw error;
    }
  }

  // Envoyer une notification en temps r√©el
  async sendRealtimeNotification(sellerId, type, data) {
    try {
      console.log(`üîî [NOTIF-START] Tentative d'envoi notification: ${type} pour vendeur ${sellerId}`);
      
      // Cr√©er la notification persistante AVANT tout envoi
      console.log(`üíæ [NOTIF-DB] Cr√©ation notification en base...`);
      const notification = await this.createNotification(
        sellerId,
        type,
        this.getTitle(type, data),
        this.getMessage(type, data),
        data
      );
      console.log(`‚úÖ [NOTIF-DB] Notification cr√©√©e avec ID: ${notification.id}`);

      // Tenter l'envoi en temps r√©el
      console.log(`üì° [NOTIF-SEND] Tentative envoi temps r√©el...`);
      const sent = await this.attemptRealtimeSend(sellerId, type, data, notification);
      
      if (sent) {
        // Marquer comme envoy√©e
        await notification.update({
          sent: true,
          sent_at: new Date()
        });
        console.log(`‚úÖ [NOTIF-SUCCESS] Notification envoy√©e en temps r√©el: ${type} (ID: ${notification.id})`);
      } else {
        // Vendeur offline - Essayer Web Push en fallback
        console.log(`üì± [NOTIF-OFFLINE] Vendeur ${sellerId} offline, tentative Web Push...`);
        const pushSent = await webPushService.sendPushNotification(sellerId, notification);
        
        if (pushSent) {
          console.log(`‚úÖ [NOTIF-PUSH] Notification envoy√©e via Web Push: ${type} (ID: ${notification.id})`);
          await notification.update({ sent: true, sent_at: new Date() });
        } else {
          // Ajouter √† la queue de retry (priorit√© BullMQ)
          console.log(`‚è≥ [NOTIF-QUEUE] Ajout √† la queue de retry...`);
          try {
            if (this.useBullMQ && notificationQueue?.isInitialized) {
              await notificationQueue.addNotification(
                notification.id,
                sellerId,
                type,
                data,
                type === 'new_order' ? 'high' : 'normal'
              );
              console.log(`‚úÖ [NOTIF-BULLMQ] Notification ${notification.id} ajout√©e √† BullMQ`);
            } else {
              console.log(`‚ö†Ô∏è [NOTIF-FALLBACK] BullMQ non disponible, utilisation queue m√©moire`);
              this.addToRetryQueue(notification);
              console.log(`‚úÖ [NOTIF-MEMORY] Notification ${notification.id} ajout√©e √† la queue m√©moire`);
            }
          } catch (queueError) {
            console.error('‚ùå [NOTIF-QUEUE-ERROR] Erreur ajout √† la queue, fallback m√©moire:', queueError);
            this.addToRetryQueue(notification);
          }
        }
      }

      // Envoyer des √©v√©nements de mise √† jour sp√©cifiques
      await this.sendUpdateEvents(sellerId, type, data);

      return { notification, sent };
    } catch (error) {
      console.error('‚ùå Erreur envoi notification:', error);
      throw error;
    }
  }

  // Envoyer des √©v√©nements de mise √† jour sp√©cifiques
  async sendUpdateEvents(sellerId, type, data) {
    try {
      if (global.notifySeller) {
        // √âv√©nements sp√©cifiques selon le type
        switch (type) {
          case 'new_order':
            global.notifySeller(sellerId, 'order_updated', {
              orderId: data.order?.id,
              action: 'created',
              timestamp: new Date()
            });
            break;
          case 'order_status_update':
            global.notifySeller(sellerId, 'order_updated', {
              orderId: data.order?.id,
              action: 'status_changed',
              newStatus: data.order?.status,
              timestamp: new Date()
            });
            break;
          case 'product_updated':
            global.notifySeller(sellerId, 'product_updated', {
              productId: data.product?.id,
              action: 'updated',
              timestamp: new Date()
            });
            break;
          case 'credits_updated':
            global.notifySeller(sellerId, 'credits_updated', {
              newCredits: data.newCredits,
              change: data.change,
              timestamp: new Date()
            });
            break;
        }

        // √âv√©nement de mise √† jour des statistiques
        global.notifySeller(sellerId, 'stats_updated', {
          timestamp: new Date()
        });

        console.log(`üì° √âv√©nements de mise √† jour envoy√©s pour vendeur ${sellerId}`);
      }
    } catch (error) {
      console.error('‚ùå Erreur envoi √©v√©nements de mise √† jour:', error);
    }
  }

  // Tenter l'envoi en temps r√©el
  async attemptRealtimeSend(sellerId, type, data, notification = null) {
    try {
      console.log(`üîç V√©rification global.notifySeller pour vendeur ${sellerId}...`);
      
      if (global.notifySeller) {
        console.log(`üì° [NOTIF-WS] Envoi via WebSocket pour vendeur ${sellerId}...`);
        
        // Ajouter l'ID de notification aux donn√©es si disponible
        let dataToSend = data;
        if (notification) {
          dataToSend = {
            ...data,
            notification: {
              id: notification.id,
              type: notification.type,
              title: notification.title,
              message: notification.message,
              created_at: notification.created_at
            }
          };
        }
        
        // Attendre l'ACK du client
        const ackReceived = await global.notifySeller(sellerId, type, dataToSend);
        
        if (ackReceived) {
          console.log(`‚úÖ [NOTIF-WS] Notification WebSocket confirm√©e pour vendeur ${sellerId}${notification ? ` (ID: ${notification.id})` : ''}`);
          return true;
        } else {
          console.error(`‚ùå [NOTIF-WS] Pas d'ACK re√ßu pour vendeur ${sellerId}${notification ? ` (ID: ${notification.id})` : ''}`);
          return false;
        }
      } else {
        console.log(`‚ùå global.notifySeller non disponible pour vendeur ${sellerId}`);
        return false;
      }
    } catch (error) {
      console.error(`‚ùå Erreur envoi temps r√©el pour vendeur ${sellerId}:`, error);
      return false;
    }
  }

  // Ajouter √† la queue de retry
  addToRetryQueue(notification) {
    const key = `${notification.id}`;
    this.retryQueue.set(key, {
      notification,
      retryCount: 0,
      nextRetry: Date.now() + this.retryDelay
    });
    console.log(`üìã Notification ${notification.id} ajout√©e √† la queue de retry`);
  }

  // Traiter la queue de retry
  async processRetryQueue() {
    if (this.isProcessing) {
      console.log('‚è≥ Traitement de queue d√©j√† en cours...');
      return;
    }

    this.isProcessing = true;
    const now = Date.now();
    
    try {
      for (const [key, item] of this.retryQueue.entries()) {
        if (now >= item.nextRetry) {
          try {
            console.log(`üîÑ Tentative de retry pour notification ${item.notification.id} (${item.retryCount + 1}/${this.maxRetries})`);
            
            const sent = await this.attemptRealtimeSend(
              item.notification.seller_id,
              item.notification.type,
              item.notification.data
            );
            
            if (sent) {
              // Succ√®s - marquer comme envoy√©e et retirer de la queue
              await item.notification.update({
                sent: true,
                sent_at: new Date()
              });
              this.retryQueue.delete(key);
              console.log(`‚úÖ Retry r√©ussi pour notification ${item.notification.id}`);
            } else {
              // √âchec - incr√©menter le compteur de retry
              item.retryCount++;
              if (item.retryCount >= this.maxRetries) {
                // Nombre maximum de tentatives atteint
                await item.notification.update({
                  sent: false,
                  retry_count: item.retryCount
                });
                this.retryQueue.delete(key);
                console.log(`‚ùå Nombre maximum de retry atteint pour notification ${item.notification.id}`);
              } else {
                // Programmer le prochain retry
                item.nextRetry = now + (this.retryDelay * Math.pow(2, item.retryCount));
                console.log(`‚è≥ Prochain retry pour notification ${item.notification.id} dans ${this.retryDelay * Math.pow(2, item.retryCount)}ms`);
              }
            }
          } catch (error) {
            console.error(`‚ùå Erreur lors du retry pour notification ${item.notification.id}:`, error);
            item.retryCount++;
            if (item.retryCount >= this.maxRetries) {
              this.retryQueue.delete(key);
            }
          }
        }
      }
    } finally {
      this.isProcessing = false;
    }
  }

  // Marquer les notifications comme lues
  async markNotificationsAsRead(sellerId, notificationIds = null) {
    try {
      const whereClause = { seller_id: sellerId };
      if (notificationIds) {
        whereClause.id = { [sequelize.Op.in]: notificationIds };
      }

      await Notification.update(
        { read: true, read_at: new Date() },
        { where: whereClause }
      );

      console.log(`‚úÖ Toutes les notifications marqu√©es comme lues pour vendeur ${sellerId}`);
    } catch (error) {
      console.error('‚ùå Erreur marquage notifications:', error);
      throw error;
    }
  }

  // Statistiques des notifications
  async getNotificationStats(sellerId) {
    try {
      const stats = await Notification.findAll({
        where: { seller_id: sellerId },
        attributes: [
          'type',
          'read',
          'sent',
          [sequelize.fn('COUNT', sequelize.col('id')), 'count']
        ],
        group: ['type', 'read', 'sent']
      });

      return stats;
    } catch (error) {
      console.error('‚ùå Erreur statistiques notifications:', error);
      throw error;
    }
  }

  // Nettoyer les anciennes notifications
  async cleanupOldNotifications(daysToKeep = 30) {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

      const deletedCount = await Notification.destroy({
        where: {
          created_at: {
            [sequelize.Op.lt]: cutoffDate
          },
          read: true
        }
      });

      console.log(`üóëÔ∏è ${deletedCount} anciennes notifications supprim√©es`);
      return deletedCount;
    } catch (error) {
      console.error('‚ùå Erreur nettoyage notifications:', error);
      throw error;
    }
  }

  // Utilitaires pour les titres et messages
  getTitle(type, data) {
    switch (type) {
      case 'new_order':
        return `Nouvelle commande #${data.order?.id}`;
      case 'order_status_update':
        return `Commande #${data.order?.id} mise √† jour`;
      case 'new_comment':
        return 'Nouveau commentaire';
      default:
        return 'Notification';
    }
  }

  getMessage(type, data) {
    switch (type) {
      case 'new_order':
        return `Nouvelle commande de ${data.order?.customer_name} - ${data.order?.total_price?.toLocaleString()} FCFA`;
      case 'order_status_update':
        return `Commande #${data.order?.id} : ${data.order?.status}`;
      case 'new_comment':
        return data.comment || 'Nouveau commentaire re√ßu';
      default:
        return data.message || 'Notification syst√®me';
    }
  }

  // D√©marrer le traitement de la queue
  async startRetryProcessor() {
    // Initialiser BullMQ
    await this.initializeQueue();

    // D√©marrer le processeur fallback (au cas o√π BullMQ est indisponible)
    if (!this.useBullMQ) {
      this.retryInterval = setInterval(() => {
        this.processRetryQueue();
      }, 10000); // Toutes les 10 secondes
      console.log('üîÑ Processeur de retry fallback d√©marr√© (intervalle: 10s)');
    }

    // Nettoyage p√©riodique des anciens jobs BullMQ
    if (this.useBullMQ) {
      this.cleanupInterval = setInterval(async () => {
        await notificationQueue.cleanOldJobs();
        await notificationQueue.logStats();
      }, 60 * 60 * 1000); // Toutes les heures
      console.log('üîÑ Nettoyage automatique BullMQ activ√© (intervalle: 1h)');
    }
  }

  // Arr√™ter le traitement de la queue
  async stopRetryProcessor() {
    if (this.retryInterval) {
      clearInterval(this.retryInterval);
      this.retryInterval = null;
    }
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    if (this.useBullMQ) {
      await notificationQueue.close();
    }
    console.log('üõë Processeur de retry arr√™t√©');
  }

  // Obtenir le statut du service
  async getStatus() {
    const baseStatus = {
      isProcessing: this.isProcessing,
      queueSize: this.retryQueue.size,
      retryInterval: !!this.retryInterval,
      useBullMQ: this.useBullMQ
    };

    if (this.useBullMQ) {
      const bullMQStats = await notificationQueue.getStats();
      return {
        ...baseStatus,
        bullMQ: bullMQStats
      };
    }

    return baseStatus;
  }
}

// Instance singleton
const notificationService = new NotificationService();

module.exports = notificationService; 